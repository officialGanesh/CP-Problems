# CP/DSA -Problems üî•

## Repo Details
Solving problems related to CP and DSA using python programming language üöÄ

### Problems

#### 1Ô∏è‚É£ Factorial using loops
##### Factorial of any number n (say)
###### n*(n-1)*(n-2)....3*2*1

#### 2Ô∏è‚É£ Factorial using Recursion
##### Factorial of any number n (say)
###### n*(n-1)*(n-2)....3*2*1

#### 3Ô∏è‚É£ Fibonacci using Recursion
###### 0,1,1,2,3,5....

#### 4Ô∏è‚É£ Linear Search in python
###### Linear search
A linear search or sequential search is a method for finding an element within a list. 
It sequentially checks each element of the list until a match is found or the whole list has been searched.
Linear search is rarely practical because other search algorithms and schemes, such as the binary search algorithm and hash tables, allow significantly faster searching for all but short lists.

Worst-case performance:O(n)
Best-case performance:O(1)
Average performance:O(n/2)
Worst-case space complexity:O(1) iterative

#### 5Ô∏è‚É£ Binary Search in python
###### Binary Search 
Binary search also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array.
Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. 

Worst-case performance:O(log n)
Best-case performance:O(1)
Average performance:O(log n)
Worst-case space complexity:O(1)

#### 6Ô∏è‚É£ Bubble sort in python
Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. 
The pass through the list is repeated until the list is sorted.
The algorithm, which is a comparison sort, is named for the way smaller or larger elements "bubble" to the top of the list.
This simple algorithm performs poorly in real world use and is used primarily as an educational tool. 
More efficient algorithms such as quicksort, timsort, or merge sort are used by the sorting libraries built into popular programming languages such as Python and Java.

Worst-case performance:O(n^2) comparisons, O(n^2) swaps
Best-case performance:O(n) comparisons, O(1) swaps
Average performance:O(n^2) comparisons, O(n^2) swaps
Worst-case space complexity:O(n) total, O(1) auxiliary 

#### 7Ô∏è‚É£ Collatz Sequence
The Collatz conjecture is a conjecture in mathematics that concerns sequences defined as follows:
start with any positive integer n. Then each term is obtained from the previous term as follows:
if the previous term is even, the next term is one half of the previous term.
If the previous term is odd, the next term is 3 times the previous term plus 1. 
The conjecture is that no matter what value of n, the sequence will always reach 1. 
The conjecture is named after Lothar Collatz, who introduced the idea in 1937, two years after receiving his doctorate. It is also known as the 3n + 1 problem, the 3n + 1 conjecture, the Ulam conjecture, Kakutani's problem, the Thwaites conjecture, Hasse's algorithm, or the Syracuse problem. 
The sequence of numbers involved is sometimes referred to as the hailstone sequence or hailstone numbers, or as wondrous numbers. 
Paul Erd≈ës said about the Collatz conjecture: "Mathematics may not be ready for such problems." He also offered US$500 for its solution.